# 设备脚本

## 前言
**概述**

可以用脚本实现一些复杂操作，包括但不限于
- 包括键盘、鼠标在内的一系列的操作组合
- 循环，整体循环局部循环
- 控制LED灯光效果
- 更复杂的操作（丰富的指令和接口）


**导读**

- 如果你没有编程基础，或不想深入研究，仅看前3章即可
- 一般情况，直接看指令表会更快找到答案
- 如果你看不懂，请不要停下。把文档完整读一遍后再看就明白了
- 。。。

## **0.入门**

**脚本是什么？**

- 脚本就是脚本，又称作宏。
- 脚本导演了一个序列事件的发生


**脚本能做什么？**

这取决于你自己
- 你可以使用脚本操作键盘输出按键、操作鼠标进行移动/点击等
- 也可以使用脚本来控制RGB灯光效果
- 甚至可以编写一个硬件计算器

**脚本是怎么运行的？**
- 一般情况下，按键作为键盘的开关，按下按键即可执行对应的脚本
- 执行脚本的同时，按键设置的4个参数将被传入脚本的寄存器
- 脚本的执行顺序是从上至下，顺序执行，并进行对应指令的操作
- 脚本会一直执行直到**延时**、**阻塞**或**退出**指令

## **1.最简单的操作脚本**

**脚本编辑界面**  
![图片]()

**一个按键操作（上图）**
- 最基本的4个步骤： 按下、延时、松开、延时
- 延时单位是毫秒，1秒=1000毫秒。
- 延时至少1毫秒，建议至少5毫秒。太快电脑会反应不过来
- 一般人按键在30毫秒以上。

**将脚本绑定到按键**
1. 按键模式改成用户脚本+脚本编号 （No.xxx）
2. 填入参数（**不懂就不用管**）  

![图片]()

**更多键盘按键**
- 重复 按下、延时、松开、延时 四个步骤即可
- 建议直接录制

## **2.基本指令**

### 延时
- 让脚本暂停一段时间
- 延时的单位是毫秒
- 延时数值范围 0~255（使用变量除外）
	**延时倍率**
	- X1：1=1ms  填多少数字就是多少毫秒
	- X256：1=256ms  填1就是256毫秒，2就是512毫秒
	---
**随机延时**
	- 随机范围 0~ 倍率x填写的数值
	- 填入的数值**绝对**不能为0
	---
- 几个例子
**延时0.1秒（100毫秒）**
```
-延时 x1 100
```
**延时0.3秒（300毫秒）**
```
-延时 x1 200
-延时 x1 100
或
-延时 x256 1
-延时 x1 44
```
**范围延时 0.2~0.3秒**
```
一条固定延时紧跟一条随机延时即可
-延时 x1 200
-延时-随机-x1 100
```

---
### 按键操作
- 输出基本的按键操作到电脑
- 两次按键操作之间必须加延时
- 支持任意操作嵌套
**键值**
	- 直接选取按键操作
	- 操作内容固定
	---
**传参（一般用户无需使用）**
	- 通过参数传递或变量复用代码或脚本
	- 操作内容灵活
	---
- 几个例子
**按下按键A 按下时间35毫秒（短按）**
```
-一般键-键值-按下 A
-延时 x1 35
-一般键-键值-松开 A
-延时 x1 35
```
**按下按键A 按下时间2秒（长按）**
```
-一般键-键值-按下 A
-延时 x256 7
-延时 x1 208
-一般键-键值-松开 A
-延时 x1 35
```
**组合键 Ctrl+C**
```
-组合键-键值-按下 Ctrl
-延时 x1 35
-一般键-键值-按下 C
-延时 x1 35
-一般键-键值-松开 C
-延时 x1 35
-组合键-键值-松开 Ctrl
-延时 x1 35
```
**按下按键A 按下时间35毫秒（短按）并循环执行**
```
-一般键-键值-按下 A
-延时 x1 35
-一般键-键值-松开 A
-延时 x1 35
-地址跳转 0 0
```
---
### 光标操作
- 移动/定位鼠标光标
- 两次按键操作之间必须加延时，操作后要再来一步清零
**轴**
	- X 屏幕横向坐标，右侧正
	- Y 屏幕纵向坐标，下侧正
	- Scroll 滚轮操作
	---
- 几个例子
**光标右移一段距离**
```
-鼠标-光标移动-值 X轴 10
-延时 x1 35
-鼠标-光标移动-值 X轴 0
-延时 x1 35
```
**光标下移一段距离**
```
-鼠标-光标移动-值 Y轴 10
-延时 x1 35
-鼠标-光标移动-值 Y轴 0
-延时 x1 35
```
**光标定位到指定坐标（x,y）并左键单击**
```
-鼠标-光标定位 100,100
-延时 x1 35
-鼠标键-键值-按下 左键
-延时 x1 35
-鼠标键-键值-松开 左键
-延时 x1 35
```


## **3.特殊指令**


**进入点动模式**
- 脚本默认是开关模式，按一下开始，（如果还在运行）再按一下停止。
- 点动模式下，脚本只能通过指令退出
- 一般放在第一条指令

**按键阻塞**
- 当运行到该步骤时，按键处于指定状态则脚本暂停运行
- 条件不成立时恢复运行
**举个例子**
**按下是A，松开是B**
```
-一般键-键值-按下 A
-延时 x1 35
-一般键-键值-松开 A
-延时 x1 35
-按键按下时阻塞
-一般键-键值-按下 B
-延时 x1 35
-一般键-键值-松开 B
-延时 x1 35
```
**按一下是A，再按一下是B（需要点动模式）**
```
-进入点动模式
-一般键-键值-按下 A
-延时 x1 35
-一般键-键值-松开 A
-延时 x1 35
-按键按下时阻塞
-按键松开时阻塞
-一般键-键值-按下 B
-延时 x1 35
-一般键-键值-松开 B
-延时 x1 35
```

### 按键状态退出
- **当运行到该步骤时**，按键处于指定状态则退出，否则向下执行
- 举个例子
**按住循环输出按键，松开退出**
```
-一般键-键值-按下 A
-延时 x1 35
-一般键-键值-松开 A
-延时 x1 35
-如果按键松开退出
-地址跳转 0 0
```


## **4.指令架构**

### 整体架构
 - 一般情况下，脚本运行在按键上。
 - 每个按键可以看做一个单独的线程，多线程运行。
 - 每个线程寄存器独立，但可通过指针访问共享内存区域。
 - 每个线程有4个8位参数寄存器（参数通过按键传入，非只读，可以独立重载）、4个32位专用寄存器（作为数据暂存或指针）、1个32位A寄存器（用于累加、乘除）、1个32位B寄存器（用作除法）。

### 跳转控制
 - 为更简单的进行跳转而无需计算地址，引入了FLAG。
 - 可通过SET_FLAG指令将下一条指令的地址压入寄存器。
 - 跳转时，如果寄存器为0则向下搜索。

### 寄存器
| 名称  |取值范围   |读写|用法   |
| --------- | ------ | ---------- |---|
| 参数1~参数4  | 0~255  | RW  |按键传入/通用寄存器|
|  R0~R3 |  0~4294967295 | RW  |通用寄存器|
|  A | 0~4294967295 | RW  |累加器/通用寄存器|
|  B | 0~4294967295 | RW  |除法寄存器/通用寄存器|
|  DPTR | 0~4294967295 | RW  |通用寄存器|
|  P_R0~P_R3 |  ? | RW  |共享RAM内存区域指针|
|  P_DPTR | ？ | RO  |数据指针|
|  IO | 0~255 | RO  |IO状态，0=按下|
|  SYS_TIME_MS | 0~4294967295 | RO  |系统时间，毫秒|
|  SYS_TIME | 0~4294967295 | RO  |系统时间，秒|
|  SYS_KB_LED | 0~255 | RO  |键盘LED状态|
|  SYS_KEY_NUM | 0~4294967295 | RO  |按键计数|
|  SYS_KEY_LAY | 0~255 | RW  |键盘层级|
|  S_SCRIPT_ADDR | 0~4294967295 | RO  |当前脚本步骤地址|
|  S_DATA_RANDOM | 0~4294967295 | RW  |R:获取一个随机数 W:设置随机数种子|




## **5.操作指令**
### 按键操作指令
- 支持多种操作，包括键盘、鼠标、多媒体等。
- 指令支持传值和传参
- 支持控制按下和松开，支持乱序/嵌套，按下操作后必须有松开步骤
- 每次操作后至少加1毫秒延时，等待主机接收到操作

```
- 组合键
- 一般键
- 鼠标键
- 多媒体
- Joystick按键
- 鼠标光标移动
- 鼠标光标定位
```

## **6.跳转指令**

脚本支持流程控制（跳转），可内部跳转或向后一个脚本跳转
目前支持以下跳转指令
 ```
 JZ  			//jump if (REG == 0)  参数值为0跳转，否则向下执行
 JNZ 			//jump if (REG != 0) 参数值不为0跳转，否则向下执行
 JC  			//jump if (CY == 0) 参数CY值为0跳转，否则向下执行
 JNC 			//jump (if CY != 0) 参数CY值不为0跳转，否则向下执行
 CJNE			//CY = (REG1 < REG2);jump if (REG1 != REG2)  如果REG1小于REG2则置位CY否则清零，如果不相等则跳转，否则向下执行
 DJNZ			//jump if (--REG != 0)  REG先减一，如果不为零跳转，否则向下执行
 ```

可以使用更易用的 SET_FLAG 将目标地址写入寄存器，然后使用 JUMP_TO_FLAG 直接跳转到寄存器存储的地址而不需要计算地址

- 几个例子：
· 短按输出A长按输出B  
![](https://dl.sayobot.cn/script/%E8%84%9A%E6%9C%AC%E4%BE%8B%E5%AD%90/短按A长按B.png)  
解析：当按下按键后脚本会启动，然后首先延时等待200毫秒再次检查按键按下状态（IO是按键状态，按下为0），如果仍然按下则识别为长按并跳转到（R0）保存的地址以输出B。否则继续执行输出A并退出；  
虽然此时（R0）并未赋值，但其默认值是0，程序会自动向后搜索直到SET_FLAG。


- 局部循环  
![](https://dl.sayobot.cn/script/%E8%84%9A%E6%9C%AC%E4%BE%8B%E5%AD%90/局部循环.png)  
次数的参数也可以通过按键传入











